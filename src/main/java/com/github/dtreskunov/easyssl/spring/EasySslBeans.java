package com.github.dtreskunov.easyssl.spring;

import java.math.BigInteger;
import java.nio.charset.Charset;
import java.security.GeneralSecurityException;
import java.security.KeyFactory;
import java.security.KeyStore;
import java.security.PrivateKey;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.security.spec.KeySpec;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.RSAPrivateCrtKeySpec;
import java.util.Base64;

import javax.net.ssl.SSLContext;
import javax.net.ssl.X509TrustManager;
import javax.servlet.Filter;

import org.apache.http.ssl.SSLContexts;
import org.apache.http.ssl.TrustStrategy;
import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;
import org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;
import org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;
import org.springframework.boot.context.embedded.Ssl;
import org.springframework.boot.context.embedded.Ssl.ClientAuth;
import org.springframework.boot.context.embedded.SslStoreProvider;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.Resource;
import org.springframework.util.StreamUtils;
import org.springframework.web.client.RestTemplate;

import com.github.dtreskunov.easyssl.CRLTrustManager;
import com.github.dtreskunov.easyssl.ClientCertificateCheckingFilter;

import sun.security.util.DerInputStream;
import sun.security.util.DerValue;

/**
 * Defines Spring beans that are used for mutual SSL. They are:
 * <ol>
 * <li>{@link #clientSSLContext} - may be used to configure an SSL-using {@link RestTemplate}</li>
 * <li>{@link #clientCertificateCheckingFilter} - checks that client's certificate has not been revoked</li>
 * <li>{@link #servletContainerCustomizer} - used by Spring Boot to configure Jetty/Tomcat/Undertow to use SSL with client cert auth</li>
 * </ol>
 */
@Configuration
@SuppressWarnings("restriction") // Sun APIs are needed to load private keys generated by openssl (PKCS#1 format)
public class EasySslBeans {
    
    /** Java APIs require a password when using a {@link KeyStore}. Hard-coded password is fine since the KeyStore is ephemeral. */
    private static final String KEY_PASSWORD = "password";
    private static final String KEY_ALIAS = "easyssl-key";

    public static SSLContext getSSLContext(EasySslProperties config) throws Exception {
        X509TrustManager trustManager = getTrustManager(config);
        TrustStrategy trustStrategy = new TrustStrategy() {
            @Override
            public boolean isTrusted(X509Certificate[] chain, String authType) throws CertificateException {
                trustManager.checkServerTrusted(chain, authType);
                return false; // still use the underlying JSSE verification
            }
        };
        
        return SSLContexts.custom()
                .loadKeyMaterial(getKeyStore(config.getCertificate(), config.getKey()), KEY_PASSWORD.toCharArray())
                .loadTrustMaterial(getTrustStore(config.getCaCertificate()), trustStrategy)
                .build();
    }

    private static byte[] convertPemToBytes(String pemString) {
        return Base64.getDecoder().decode(pemString.replaceAll("-----.*-----|\\s+", ""));
    }
    
    private static Certificate getCertificate(Resource certificate) throws Exception {
        CertificateFactory cf = CertificateFactory.getInstance("X.509");
        return cf.generateCertificate(certificate.getInputStream());
    }

    private static KeyStore getKeyStore(Resource certificate, Resource key) throws Exception {
        PrivateKey privateKey = getPrivateKey(
                StreamUtils.copyToString(key.getInputStream(), Charset.defaultCharset()));

        KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
        keyStore.load(null, null);
        keyStore.setKeyEntry(KEY_ALIAS, privateKey, KEY_PASSWORD.toCharArray(), new Certificate[]{getCertificate(certificate)});
        return keyStore;
    }
    
    private static KeySpec getPKCS1KeySpec(byte[] bytes) throws Exception {
        // http://stackoverflow.com/questions/7216969/getting-rsa-private-key-from-pem-base64-encoded-private-key-file
        DerInputStream derReader = new DerInputStream(bytes);

        DerValue[] seq = derReader.getSequence(0);

        if (seq.length < 9) {
            throw new GeneralSecurityException("Could not parse a PKCS#1 private key.");
        }

        // skip version seq[0];
        BigInteger modulus = seq[1].getBigInteger();
        BigInteger publicExp = seq[2].getBigInteger();
        BigInteger privateExp = seq[3].getBigInteger();
        BigInteger prime1 = seq[4].getBigInteger();
        BigInteger prime2 = seq[5].getBigInteger();
        BigInteger exp1 = seq[6].getBigInteger();
        BigInteger exp2 = seq[7].getBigInteger();
        BigInteger crtCoef = seq[8].getBigInteger();

        return new RSAPrivateCrtKeySpec(modulus, publicExp, privateExp, prime1, prime2, exp1, exp2, crtCoef);
    }

    private static KeySpec getPKCS8KeySpec(byte[] bytes) throws Exception {
        return new PKCS8EncodedKeySpec(bytes);
    }

    private static PrivateKey getPrivateKey(String pemString) throws Exception {
        final KeySpec keySpec;
        if (pemString.contains("-----BEGIN RSA PRIVATE KEY-----")) {
            keySpec = getPKCS1KeySpec(convertPemToBytes(pemString));
        } else if (pemString.contains("-----BEGIN PRIVATE KEY-----")) {
            keySpec = getPKCS8KeySpec(convertPemToBytes(pemString));
        } else {
            throw new GeneralSecurityException("Private key must be unencrypted, PKCS#8 or PKCS#1, in PEM format");
        }
        return KeyFactory
            .getInstance("RSA")
            .generatePrivate(keySpec);
    }
    
    private static X509TrustManager getTrustManager(EasySslProperties config) throws Exception {
        return new CRLTrustManager(
                config.getCertificateRevocationList(),
                getCertificate(config.getCaCertificate()).getPublicKey());
    }
    
    private static KeyStore getTrustStore(Resource certificate) throws Exception {
        CertificateFactory cf = CertificateFactory.getInstance("X.509");
        Certificate ca = cf.generateCertificate(certificate.getInputStream());
        
        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
        trustStore.load(null, null);
        trustStore.setCertificateEntry("easyssl-ca", ca);
        return trustStore;
    }

    private static class BootSslStoreProviderImpl implements SslStoreProvider {
        private final KeyStore m_keyStore;
        private final KeyStore m_trustStore;

        public BootSslStoreProviderImpl(KeyStore keyStore, KeyStore trustStore) {
            m_keyStore = keyStore;
            m_trustStore = trustStore;
        }

        @Override
        public KeyStore getKeyStore() throws Exception {
            return m_keyStore;
        }

        @Override
        public KeyStore getTrustStore() throws Exception {
            return m_trustStore;
        }
        
    }
    
    @Bean
    public SSLContext clientSSLContext(EasySslProperties config) throws Exception {
        return getSSLContext(config);
    }
    
    @Bean
    @ConditionalOnWebApplication
    public Filter clientCertificateCheckingFilter(EasySslProperties config) throws Exception {
        return new ClientCertificateCheckingFilter(getTrustManager(config));
    }
    
    @Bean
    @ConditionalOnWebApplication
    public EmbeddedServletContainerCustomizer servletContainerCustomizer(EasySslProperties config) throws Exception {
        final SslStoreProvider storeProvider = new BootSslStoreProviderImpl(
                getKeyStore(config.getCertificate(), config.getKey()),
                getTrustStore(config.getCaCertificate()));
        final Ssl sslProperties = getSslProperties(config);
        
        return new EmbeddedServletContainerCustomizer() {
            @Override
            public void customize(ConfigurableEmbeddedServletContainer container) {
                container.setSslStoreProvider(storeProvider);
                container.setSsl(sslProperties);
            }
        };
    }
    
    private Ssl getSslProperties(EasySslProperties config) {
        Ssl properties = new Ssl();
        properties.setEnabled(true);
        properties.setClientAuth(ClientAuth.WANT);
        properties.setKeyAlias(KEY_ALIAS);
        properties.setKeyPassword(KEY_PASSWORD);
        return properties;
    }
}
